#!/usr/bin/perl
# cg - Code Grep - Copyright 1999 by Joshua Uziel <juziel@home.com>
# This program is released under the GNU General Public License.
# cg - cgvg version 1.2
#
# Recursive Grep script that does a bit of extra work in adding a count
# field and storing the data in a file.  Run as if you were running
# grep(1) normally, with only what to search for (and use the default
# search path), or no arguments to recall last search.
# Examples: "cg main", "cg", "cg -r main *.c", "cg -i main *.c", etc.
#
# The point of this script was to provide source code searching
# functionality similar to that AT&T's cscope(1).  This is a pure
# hack and lacks any sophistication, but has the advantage that it
# can be used for more than just the C programming language, besides
# adding the functionality that is generally missing from a developer's
# toolbox.

# Where to store the data
$LOGFILE = "$ENV{'HOME'}/.cglast";

# List of things to exclude from the search
$EXCLUDE = "SCCS|RCS|tags|\.make\.state|Binary\ file";

# List of things to search for... see the manpage for find(1).
$SEARCH = "-name '*.[chs]' -o -name '*.cc' -o -name 'Make*' -o -name '*.pl' ",
		"-o -name '*.java' -o -name '*.*sh' -o -name '*.idl'";

# Generate the log if an argument, and (using $count) add another field
# to grep's output.
if ($#ARGV+1) {
	$count = 0;
	open (OUT, ">$LOGFILE");

	# Give a point of reference if we change directories.
	print OUT "PWD=",`pwd`;

	$nondash = 0;
	foreach (@ARGV) {
		$nondash++ unless (/^-/);
		break if ($nondash >= 2);
	}

	if ($nondash >= 2) {

		foreach (`fgrep -n @ARGV /dev/null | egrep -v "$EXCLUDE"`) {
			print OUT "$count:$_";
			$count++;
		}

	} else {	# Default search - this is faster and preferable.

		# This is the magical line... find all files that fall within
		# our desired filenames/extensions, excluding all pathnames
		# that we don't want.
		@list = `find . \\\( $SEARCH \\\) -print | egrep -v "$EXCLUDE"`;

		# Special case of no matching files, we die with an error.
		die "error: No matching files found.\n" if ($#list < 0);

		# Remove the leading "./" since we don't need it.
		foreach (@list) {
			s/^\.\///;
		}

		# Remove trailing newlines.
		chomp @list;

		# Grep for it in our list, allowing arguments to grep, and
		# adding the extra count field.  Note we also search /dev/null.
		# This is so if we have one real arg, grep will think we have
		# two to trick it into always giving us the filename.
		foreach (`fgrep -n @ARGV @list /dev/null`) {
			print OUT "$count:$_";
			$count++;
		}
	}
	close (OUT);
}

# Either way, we print the log... this part works to reformat things
# differently from how it's stored to make it easier on the human eyes.

# Attempt to get the number of columns from an "stty -a"
if ($COL = `stty -a | grep column 2> /dev/null`) {

	# Strip out the value with the string "column"
	@TMP = split ';', $COL;
	foreach $tmp (@TMP) {
		$COL = $tmp if ($tmp =~ /column/);
	}
	$COL =~ s/\D*(\d+)\D*/$1/;

	# Something's weird if 0, and we want more than 40.
	die "Error: Zero value found for number of columns.\n" if ($COL == 0);
	die "Error: Too few columns to work with.\n" if ($COL < 40);

	# Adjust things to be a little smaller than the width.
	$COL -= 2;
} else {
	# Default assumption is 80 columns, so do 2 less than it.
	$COL = 78;
}

# Exit there's no logfile.
die "Error: $LOGFILE does not exist.\n" unless (-f "$LOGFILE");

open (IN, "<$LOGFILE");
<IN>;	# Waste the first line, used for PWD.

# $m* are used as "max" variables... maximum length at this point.
$mnum = $mline = $mfile = $i = 0;

while ($in = <IN>) {
	chomp $in;

	# Split and strip the first few colons, leave the rest.
	($rec[$i]->{num}, $rec[$i]->{file}, $rec[$i]->{line}, $rec[$i]->{str}) 
		= split /:/, $in, 4;

	# Remove all leading whitespace.
	$rec[$i]->{str} =~ s/^\s*//;

	# Swap tabs for 8 spaces
	$rec[$i]->{str} =~ s/\t/        /g;
	
	# If we have a longer length for this field, save it. 
	$tmp = length $rec[$i]->{file};
	$mfile = $tmp if ($mfile < $tmp);
	$tmp = length $rec[$i]->{line};
	$mline = $tmp if ($mline < $tmp);

	$i++;
}

# Better than doing this every time like $mfile and $line ...
$mnum = length ($i-1);

# Skip inward the 3 lengths and the spaces separating them.
$skip = $mnum + $mfile + $mline + 3;

# Special case I call "wrapmode" when we're to skip so much that we
# can't even fit 20 characters (and in some cases negative characters).
# Go to next line and automatically skip a tab's worth.
if (($skip + 20) >= $COL) {
	$wrapmode = 1;
	$skip = 8;
}

# Length for the string is the whole line minus length of others.
# Hopefully $COL is adjusted terminal's width.
$mstr = $COL - $skip;

$entries = $i;

for ($i=0; $i < $entries; $i++) {
	# Print the properly justified first 3 fields.
	printf "%${mnum}s %-${mfile}s %${mline}s ", $rec[$i]->{num}, 
					$rec[$i]->{file}, $rec[$i]->{line};

	# Newline only for "wrapmode".
	print "\n" if ($wrapmode);

	# Trickery for the string.  Do this as many times as we've got
	# str's length divided by it's maximum possible length.
	for ($j=0; $j < ((length $rec[$i]->{str}) / $mstr); $j++) {

		# Only skip after first line.
		print " " x $skip if ($j || $wrapmode);

		# Print only $mstr character substring.
		print substr $rec[$i]->{str}, ($j*$mstr), $mstr;
		print "\n";
	}
}

close (IN);
