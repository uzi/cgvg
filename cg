#!/usr/bin/perl
# cg - Code Grep - grep recursively through files and disiplay matches
# Copyright 1999 by Joshua Uziel <juziel@home.com> - version 1.4
#
# Recursive Grep script that does a bit of extra work in adding a count
# field and storing the data in a file.  Run as if you were running
# grep(1) normally, with only what to search for (and use the default
# search path), or no arguments to recall last search.
# Examples: "cg printf", "cg", "cg printf '*.c'", "cg -i printf '*.c'", etc.
#
# The point of this script was to provide source code searching
# functionality similar to that AT&T's cscope(1).  This is a pure
# hack and lacks any sophistication, but has the advantage that it
# can be used for more than just the C programming language, besides
# adding the functionality that is generally missing from a developer's
# toolbox.
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

use POSIX;
use File::Find;
require "find.pl";

# Search for wanted entries for perl internal find subroutine.
sub wanted {

	# If there isn't a specified thing to search for, use the default.
	unless ($nondash) {
		if ( 

		# Skip things that aren't normal files (like directories).
		(($dev,$ino,$mode,$nlink,$uid,$gid) = lstat($_)) && -f _ &&

		/^.*\.[chs]$/       # *.c, *.h and *.s 
		||
		/^.*\.cc$/          # *.cc
		||
		/^Make.*$/          # Make*
		||
		/^.*\.pl$/          # *.pl
		||
		/^.*\.java$/        # *.java
		||
		/^.*\..*sh$/        # *.*sh
		||
		/^.*\.idl$/         # *.idl

		) {
			# Kill the leading ./ and push it on the @LIST
			$name =~ s/^\.\///;
			push @LIST, $name;
		}
	} else {
		# Search files that match $SEARCH
		if ( 

		# Skip things that aren't normal files (like directories).
		(($dev,$ino,$mode,$nlink,$uid,$gid) = lstat($_)) && -f _ &&

		# User-definable search...
		/^$SEARCH$/
		) {
			# Kill the leading ./ and push it on the @LIST
			$name =~ s/^\.\///;
			push @LIST, $name;
		}
	}
}

# Where to store the data
$LOGFILE = "$ENV{'HOME'}/.cglast";

# Path to the rc file
$RCFILE = "$ENV{'HOME'}/.cgvgrc";

# List of things to exclude from the search
$EXCLUDE = "SCCS|RCS|tags|\.make\.state|Binary\ file";

# Set if you want colors (and your term supports it).  This is required
# for the $BOLD* options.
$COLORS = 1;

# Have everything printed in bold... 1 (yes) or 0 (no) only.  This option
# is overrided by $BOLD_ALTERNATE and only available with $COLORS
$BOLD = 0;

# Make every other line bold.
$BOLD_ALTERNATE = 1;

# Defined colors
%colors = ( 'black'	=> "30",
	    'red'	=> "31",
	    'green'	=> "32",
	    'yellow'	=> "33",
	    'blue'	=> "34",
	    'magenta'	=> "35",
	    'cyan'	=> "36",
	    'white'	=> "37");

# Color for column #
$c1 = $colors{'cyan'};
$c2 = $colors{'blue'};
$c3 = $colors{'red'};
$c4 = $colors{'green'};

# Check if stdout goes to a tty... can't do colors if we pipe to another
# program like "more" or "less" or to a file.
$COLORS = POSIX::isatty(fileno STDOUT) if ($COLORS);

# If the rc file exists, parse it and override the defaults.
if (-f $RCFILE) {
	open (IN, "<$RCFILE");
	
	while (<IN>) {
		chomp;
		
		# Strip leading spaces and skip blank and comment lines.
		s/^\s*//;
		next if (/^#/);
		next if (/^$/);
		
		($key, $value) = split /=/;

		if ($key =~ /COLORS/) {
			$COLORS=$value;
		} elsif ($key =~ /BOLD$/) {
			$BOLD=$value;
		} elsif ($key =~ /BOLD_ALTERNATE/) {
			$BOLD_ALTERNATE=$value;
		} elsif ($key =~ /EDITOR/) {
			$EDITOR=$value;
		} else {
			die "error: Unknown option in $RCFILE\n";
		}
	}

	close (IN);
}

# Generate the log if an argument, and (using $count) add another field
# to grep's output.
if ($#ARGV+1) {
	$count = 0;
	open (OUT, ">$LOGFILE");

	# Give a point of reference if we change directories.
	print OUT "PWD=",`pwd`;

	# Set @ARG's for grep and the file $SEARCH (if any) while counting
	# non-dash arguments.  More than one means we have a $SEARCH, else
	# we use the default list of files to search through.
	$nondash = 0;
	foreach (@ARGV) {
		if (/^-/) {
			push @ARG, $_;
		} else {
			if ($nondash) {
				$SEARCH = $_;
				$SEARCH =~ s/\./\\\./g;	# . for \.
				$SEARCH =~ s/\*/\.\*/g;	# * for .*
			} else {
				push @ARG, $_;
			}
			$nondash++;
		}
	}
	$nondash--;

	die "error: You should quote search globs (like '*.c').\n"
		if ($nondash >= 2);

	# Initialize @LIST so it's now global and do the find...
	@LIST;
	&find('.');

	# Special case of no matching files, we die with an error.
	die "error: No matching files found.\n" if ($#LIST <= 0);

	# Grep for it in our list, allowing arguments to grep, and
	# adding the extra count field.  Note we also search /dev/null.
	# This is so if we have one real arg, grep will think we have
	# two to trick it into always giving us the filename.
	foreach (`fgrep -n @ARG @LIST /dev/null | \
					egrep -v "$EXCLUDE"`) {
		print OUT "$count:$_";
		$count++;
	}

	close (OUT);
}

# Either way, we print the log... this part works to reformat things
# differently from how it's stored to make it easier on the human eyes.

# Attempt to get the number of columns from an "stty -a"
if ($COL = `stty -a | grep column 2> /dev/null`) {

	# Strip out the value with the string "column"
	@TMP = split ';', $COL;
	foreach $tmp (@TMP) {
		$COL = $tmp if ($tmp =~ /column/);
	}
	$COL =~ s/\D*(\d+)\D*/$1/;

	# Something's weird if 0, and we want more than 40.
	die "Error: Zero value found for number of columns.\n" if ($COL == 0);
	die "Error: Too few columns to work with.\n" if ($COL < 40);

	# Adjust things to be a little smaller than the width.
	$COL -= 2;
} else {
	# Default assumption is 80 columns, so do 2 less than it.
	$COL = 78;
}

# Exit there's no logfile.
die "Error: $LOGFILE does not exist.\n" unless (-f "$LOGFILE");

open (IN, "<$LOGFILE");
<IN>;	# Waste the first line, used for PWD.

# $m* are used as "max" variables... maximum length at this point.
$mnum = $mline = $mfile = $i = 0;

while ($in = <IN>) {
	chomp $in;

	# Split and strip the first few colons, leave the rest.
	($rec[$i]->{num}, $rec[$i]->{file}, $rec[$i]->{line}, $rec[$i]->{str}) 
		= split /:/, $in, 4;

	# Remove all leading whitespace.
	$rec[$i]->{str} =~ s/^\s*//;

	# Swap tabs for 8 spaces
	$rec[$i]->{str} =~ s/\t/        /g;
	
	# If we have a longer length for this field, save it. 
	$tmp = length $rec[$i]->{file};
	$mfile = $tmp if ($mfile < $tmp);
	$tmp = length $rec[$i]->{line};
	$mline = $tmp if ($mline < $tmp);

	$i++;
}

# Better than doing this every time like $mfile and $line ...
$mnum = length ($i-1);

# Skip inward the 3 lengths and the spaces separating them.
$skip = $mnum + $mfile + $mline + 3;

# Special case I call "wrapmode" when we're to skip so much that we
# can't even fit 20 characters (and in some cases negative characters).
# Go to next line and automatically skip a tab's worth.
if (($skip + 20) >= $COL) {
	$wrapmode = 1;
	$skip = 8;
}

# Length for the string is the whole line minus length of others.
# Hopefully $COL is adjusted terminal's width.
$mstr = $COL - $skip;

$entries = $i;

for ($i=0; $i < $entries; $i++) {

	# Bold every other entry
	$BOLD = ($i % 2) if ($BOLD_ALTERNATE);
	
	# Print the properly justified first 3 fields.
	print "\e[$BOLD;${c1}m" if ($COLORS);
	printf "%${mnum}s ", $rec[$i]->{num};  
	print "\e[0m" if ($COLORS);

	print "\e[$BOLD;${c2}m" if ($COLORS);
	printf "%-${mfile}s ", $rec[$i]->{file}; 
	print "\e[0m" if ($COLORS);
	
	print "\e[$BOLD;${c3}m" if ($COLORS);
	printf "%${mline}s ", $rec[$i]->{line};
	print "\e[0m" if ($COLORS);

	# Newline only for "wrapmode".
	print "\n" if ($wrapmode);

	# Trickery for the string.  Do this as many times as we've got
	# str's length divided by it's maximum possible length.
	for ($j=0; $j < ((length $rec[$i]->{str}) / $mstr); $j++) {

		# Only skip after first line.
		print " " x $skip if ($j || $wrapmode);

		# Print only $mstr character substring.
		print "\e[$BOLD;${c4}m" if ($COLORS);
		print substr $rec[$i]->{str}, ($j*$mstr), $mstr;
		print "\e[0m" if ($COLORS);
		print "\n";
	}
}

close (IN);
